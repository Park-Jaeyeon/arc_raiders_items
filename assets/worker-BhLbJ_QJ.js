var E=Object.defineProperty;var M=(o,e,r)=>e in o?E(o,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):o[e]=r;var p=(o,e,r)=>M(o,typeof e!="symbol"?e+"":e,r);const v="https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2/dist/transformers.min.js",w="Xenova/clip-vit-base-patch32";let l=null;async function k(){if(!l){console.log("[Worker] Importing transformers from CDN...");try{const o=await import(v);l=o.default||o,console.log("[Worker] Transformers module keys:",Object.keys(l)),l.env||o.env&&(l.env=o.env);const e={allowLocalModels:!1,allowRemoteModels:!0,localModelPath:"/models/",useBrowserCache:!1};l.env&&Object.assign(l.env,e),self.transformers&&self.transformers.env&&Object.assign(self.transformers.env,e),console.log("[Worker] Transformers loaded and configured.")}catch(o){throw console.error("[Worker] Failed to load transformers from CDN:",o),o}}return l}class f{static async getInstance(){const e=await k(),r=e.CLIPVisionModelWithProjection||e.CLIPVisionModel||e.AutoModel,{AutoProcessor:n}=e;if(!r||!n)throw new Error(`Failed to load VisionModel or AutoProcessor. Keys: ${Object.keys(e)}`);return this.modelPromise||(console.time("Loading Model"),console.log(`Loading CLIP vision model (${w})...`),this.modelPromise=r.from_pretrained(w,{quantized:!0}),this.processorPromise=n.from_pretrained(w),await Promise.all([this.modelPromise,this.processorPromise]),console.timeEnd("Loading Model")),Promise.all([this.modelPromise,this.processorPromise])}}p(f,"modelPromise",null),p(f,"processorPromise",null);const W=o=>{let e=0;for(let r=0;r<o.length;r++)e+=o[r]*o[r];return e=Math.sqrt(e)||1,Array.from(o,r=>r/e)},j=(o,e)=>{const r=Math.min(o.length,e.length);let n=0;for(let t=0;t<r;t++)n+=o[t]*e[t];return n};let A=null;const R=async()=>(A||(console.log("[Worker] Loading embeddings.json..."),A=(async()=>{try{const o=await fetch("/embeddings.json");if(!o.ok)throw new Error(`Failed to fetch embeddings: ${o.status}`);const e=await o.json(),r={};return Object.entries(e).forEach(([n,t])=>{Array.isArray(t)&&(r[n]=W(t))}),console.log(`[Worker] Loaded ${Object.keys(r).length} embeddings.`),r}catch(o){throw console.error("[Worker] Failed to load embeddings:",o),o}})()),A),y=async o=>{console.log(`[Worker] embedBatch: Processing ${o.length} images...`);const{RawImage:e}=await k(),[r,n]=await f.getInstance();console.log("[Worker] Reading images...");const t=await Promise.all(o.map(a=>e.read(a)));console.log("[Worker] Preprocessing images...");const s=await n(t);console.log("[Worker] Running model inference...");const m=await r(s);console.log("[Worker] Inference complete.");const g=m.image_embeds||m.pooler_output||m.last_hidden_state;if(!g||!g.data)throw console.error("[Worker] Invalid model output:",m),new Error("Model output is missing embeddings data.");const u=g.data,i=g.dims;if(!i||i.length<2)throw new Error(`Invalid output dimensions: ${i}`);const h=i[0],c=i[1];console.log(`[Worker] Output dims: [${h}, ${c}]`);const d=[];for(let a=0;a<h;a++){const b=a*c,I=b+c,P=Array.from(u.slice(b,I));d.push(W(P))}return d};self.onmessage=async o=>{const{id:e,type:r,images:n,candidatesList:t}=o.data;if(console.log(`[Worker] Received message: ${r} (ID: ${e})`),r==="init"){try{await k(),await f.getInstance();try{console.time("Warm-up"),console.log("[Worker] Starting warm-up..."),await y(["data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg=="]),console.timeEnd("Warm-up"),console.log("[Worker] Warm-up complete.")}catch(s){console.warn("Warm-up failed (non-fatal):",s)}self.postMessage({id:e,status:"ready"})}catch(s){console.error("Worker Init Error:",s),self.postMessage({id:e,status:"error",error:s instanceof Error?s.message:"Initialization failed"})}return}if(r==="analyze_batch"){try{console.time(`BatchInference-${e}`),console.log("[Worker] Start loading embeddings for batch...");const s=await R();console.log("[Worker] Embeddings loaded. Starting batch embedding...");const m=await y(n);console.timeEnd(`BatchInference-${e}`);const g=m.map((u,i)=>{const c=(t&&t[i]&&t[i].length>0?t[i]:Object.keys(s)).map(d=>{const a=s[d];return a?{label:d,score:j(u,a)}:null}).filter(Boolean);return c.length===0?{label:"Unknown",score:0}:(c.sort((d,a)=>a.score-d.score),c[0])});self.postMessage({id:e,status:"success",results:g})}catch(s){console.error("Worker Batch Error:",s),self.postMessage({id:e,status:"error",error:s instanceof Error?s.message:"Unknown error"})}return}};
